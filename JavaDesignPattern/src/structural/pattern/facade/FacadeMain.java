package structural.pattern.facade;
/** 
 * @Facade : 서브시스템에 있는 인터페이스 집합에 대해서 하나의 통합된 인터페이스를 제공하는 패턴으로, 서브시스템을 좀더 사용하기
 * 편하게 만드는 상위 수준의 인터페이스를 정의함.
 * ----------------------------------------------------------------------------------------------------------------
 * FacadeMain 클래스에서는 TV, Audio, Light 등의 클래스의 인스턴스를 가지고 있긴하지만, Home을 생성하는 용도
 * 외에는 사용하지 않습니다. TV나 Audio 등이 저차원 클래스라면, Home은 저차원 클래스들을 감싸고 있는 고차원 클래스
 * 입니다. 실질적인 저차원 클래스들의 조합은 바로 고차원 클래스인 Home클래스가 담당합니다. 클라이언트인 Test클래스는 고차원
 * 클래스만 신경씁니다.
 * ----------------------------------------------------------------------------------------------------------------
 * @Facade특징 
 * 예제에서 굳이 TV, Light, Audio라는 클래스들을 만들지 않고, Home 클래스 안에다가 기능을 다 넣을 수도 있었습니다.
 * 그런데, TV가 꼭 Home에 종속되어야 할까요? 요즘은 핸드폰으로도 TV보는 세상인데요. Facade 패턴을 사용하면 최소단위로
 * 클래스를 설계할 수 있습니다. 물론, 지나치게 잘게 쪼개는 것도 그다지 바람직하진 않습니다 . 코드를 다른 데에 복사해서 사용하지
 * 않는 선 정도에서 클래스를 분리시키면 될 것 같습니다. 예제코드의 경우 TV를 분리시키지 않는다면 핸드폰 클래스가 나왔을 때,
 * 핸드폰 클래스의 TV기능을 다시 구현해야하는 사태가 발생합니다.
 * ----------------------------------------------------------------------------------------------------------------
 * {@link http://iilii.egloos.com/3891647}
 */
public class FacadeMain {


	public static void main(String[] args) {
		// TODO Auto-generated method stub

		TV tv = new TV();
		Audio audio = new Audio();
		Light light = new Light();
		Home home = new Home(audio, light, tv);

		home.enjoyTv();
		home.enjoyMusic();
		home.goOut();
	}

}
